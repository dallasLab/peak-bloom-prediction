---
title: "Feature Creation"
author: "Grant Foster"
date: "2/17/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#install.packages(tidyverse)
#install.packages(zoo)
library(tidyverse)
library(zoo)
```

```{r}
cherry <- read.csv("../data/washingtondc.csv") %>% 
  bind_rows(read.csv("../data/liestal.csv")) %>% 
  bind_rows(read.csv("../data/kyoto.csv"))

cherry <- dplyr::filter(cherry, year >1950)

cherry$bloom_doy <- cherry$bloom_doy + 122 #Set Bloom day to be as same scale as climate data

cherry2 <- cherry
```

September 1st C_day is 244. 

Read in historic climate data.

```{r}
historic_covs <- read.table(file="../data/covariates/historic_climate.txt")
historic_covs <- dplyr::filter(historic_covs, year >= 1950)
```
Assign a "cherry year" to match winter weather with spring blooms. 
```{r}
historic_covs <- dplyr::filter(historic_covs, month <5 | month >8)
historic_covs$cherry_year <- 0

historic_covs$cherry_year[historic_covs$month >8] <- historic_covs$year[historic_covs$month >8]+1
historic_covs$cherry_year[historic_covs$month <8] <- historic_covs$year[historic_covs$month <8]
```

C_day as read in is unique integer identifier, where 1=Jan first. Below I reset to where September 1st is equal to 1, so that the climate dates relevant for a given bloom year are 1-243. 

```{r}
historic_covs$C_day <- historic_covs$C_day-243 #Set Sept1-Dec31 as 1-122

historic_covs$C_day[historic_covs$C_day<0] <- historic_covs$C_day[historic_covs$C_day<0] - min(historic_covs$C_day) + max(historic_covs$C_day)  
```

1) Function for the Number of Days in the Time Series (or Month) that meets a given criteria
```{r}
#' For each year-site combination, counts the number of days in historic_covs that meet a certain condition. 
#' Relies on historic coves to be loaded in environment
#' Default is to search across the entire time series, but optional @month_input param allows you to only search within a given month instead. 

#' @param condition. Counts the number of days that meet this condition (ex. tmax <0)
#' @param columnName. The name of the column of counts
#' @param month_input. Allows you to search over a particular month, encoded as an integer 1-12. Leaving this blank will search over the entire year

#' @output A three column dataframe containing the following
#' "year": The year that the covariate is relevant to (i.e. Temperatures in the winter of 1951 will be labeled as 1952, since that's the bloom they effect)
#' "location"
#' "columnName": Your output value; if left joined to "cherry" above, this will be the only added column


countDays <- function(condition, columnName, month_input=NA){
  if(is.na(month_input)==TRUE){
output <- historic_covs %>% group_by(., cherry_year, location) %>% dplyr::summarise(., temp=length(which({{condition}}))) #
colnames(output) <- c("year", "location", columnName)
return(output)
  }
  else{
    set <- dplyr::filter(historic_covs, month==month_input)
    output <- set %>% group_by(., cherry_year, location) %>% dplyr::summarise(., temp=length(which({{condition}}))) #
    colnames(output) <- c("year", "location", columnName)
    return(output)
  }
}

#Example: Count the number of total days below 0
cherry <- countDays(tmax<0, columnName="DaysSub0") %>% left_join(cherry, ., by=c("year", "location")) 

#Example 2: Count the number of total days below 0 in December
table(is.na(countDays(tmax>0, columnName="DecDaysAbove0", month=12)$DecDaysAbove0))

```

2) Function for the First Day of the Time Series (or Month) that meets a given criteria

Note:This is returned in C_Day, the unique day identifier.
```{r}
#' For each year-site combination, returns the first day in historic_covs that meet a certain condition. 
#' Returned value is in terms of C_day, which is the unique day identifier for each year
#' If no day in the designated time series meets the criteria, returns NA
#' Relies on historic coves to be loaded in environment
#' Default is to search across the entire time series, but optional @month_input param allows you to only search within a given month instead. 

#' params and outputs follow same convention as @countDays

firstDay <- function(condition, columnName, month_input=NA){
  if(is.na(month_input)==TRUE){
output <- historic_covs %>% group_by(., cherry_year, location) %>% summarise(., temp=C_day[min(which({{condition}}), na.rm = TRUE)]) #
 output$temp[is.infinite(output$temp)==TRUE] <- NA
colnames(output) <- c("year", "location", columnName)
  }
  else{
    set <- dplyr::filter(historic_covs, month==month_input)
    output <- set %>% group_by(., cherry_year, location) %>% summarise(., temp=C_day[min(which({{condition}}), na.rm=TRUE)]) #
    output$temp[is.infinite(output$temp)==TRUE] <- NA
    colnames(output) <- c("year", "location", columnName)
  }
  return(output)
}

firstDay(condition=tmax<0, columnName="FirstSub0")
firstDay(condition=tmax<0, columnName="FirstDecSub0", 12)



#Example: Record the First Day of each Growing Season (September-April) that falls below 0
cherry <- firstDay(tmax<0, columnName="FirstSub0") %>% left_join(cherry, ., by=c("year", "location")) 

#Example 2: Count the number of total days below 0 in December
cherry <- firstDay(tmax<0, columnName="FirstDecSub0", month=12) %>% left_join(cherry, ., by=c("year", "location")) 
```

3) Function for the Number of consecutive days under or over a certain threshold.

(Note: This function throws warnings from the max function each time you have a year-site combination that doesn't meet the criteria, which can be a lot)
```{r}
#' For each year-site combination, returns the number of consecutive days in historic_covs that meet a certain condition. 
#' Relies on historic coves to be loaded in environment
#' Default is to search across the entire time series, but optional @month_input param allows you to only search within a given month instead. 

#' params and outputs follow same convention as @countDays

consecDays <- function(condition, columnName, month_input=NA){
  if(is.na(month_input)==TRUE){
  output <- historic_covs %>% group_by(., cherry_year, location) %>% 
    summarise(., temp=max(rle({{condition}})$length[rle({{condition}})$values==TRUE], na.rm=TRUE)) #
    output$temp[is.infinite(output$temp)==TRUE] <- 0
    output$temp[is.na(output$temp)==TRUE] <- 0 #I think this is correct; let me make sure!
colnames(output) <- c("year", "location", columnName)
  }
  else{
    set <- dplyr::filter(historic_covs, month==month_input)
    output <- set %>% group_by(., cherry_year, location) %>% 
    summarise(., temp=max(rle({{condition}})$length[rle({{condition}})$values==TRUE], na.rm=TRUE)) #
    output$temp[is.infinite(output$temp)==TRUE] <- 0
colnames(output) <- c("year", "location", columnName)
  }
  return(output)
}


cherry <- consecDays(tmax<0, columnName = "SeqSub0") %>% left_join(cherry, ., by=c("year", "location")) 

#Ex 1. Find longest consecutive number of days in January T_max is below 0
cherry <- consecDays(tmax<0, columnName = "JanSeqSub0", month_input = 1) %>% left_join(cherry, ., by=c("year", "location")) 
```

Note that you can include multiple operations in the "condition" argument of each function
```{r}
consecDays(condition = tmax>0 & tmax <5, columnName = "Above0Sub5consec")
```

Create covariates. Creates a total of 39 as of now. 
```{r}

cherry <- cherry2
#Cumulative Thresholds

## Above
### Total Time Series

cherry <- countDays(tmax>0, columnName = "TmaxDaysAbove0") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>5, columnName = "TmaxDaysAbove5") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>10, columnName = "TmaxDaysAbove10") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>20, columnName = "TmaxDaysAbove20") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>25, columnName = "TmaxDaysAbove25") %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- countDays(tmin>0, columnName = "TminDaysAbove0") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmin>5, columnName = "TminDaysAbove5") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmin>10, columnName = "TminDaysAbove10") %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- countDays(prcp>0, columnName = "PrcpDays") %>% left_join(cherry, ., by=c("year", "location")) 

### Months
cherry <- countDays(tmax>0, columnName = "TmaxDecAbove0", month=12) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>0, columnName = "TmaxJanAbove0", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax>0, columnName = "TmaxFebAbove0", month=12) %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- countDays(prcp>0, columnName = "DecPrcpDays", month=12) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(prcp>0, columnName = "JanPrcpDays", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(prcp>0, columnName = "FebPrcpDays", month=2) %>% left_join(cherry, ., by=c("year", "location")) 


## Below
cherry <- countDays(tmax<0, columnName = "TmaxDaysSub0") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax<5, columnName = "TmaxDaysSub5") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax<10, columnName = "TmaxDaysSub10") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax<20, columnName = "TmaxDaysSub20") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmax<25, columnName = "TmaxDaysSub25") %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- countDays(tmin<0, columnName = "TminDaysSub0") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmin<5, columnName = "TminDaysSub5") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmin<8, columnName = "TminDaysSub8") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- countDays(tmin<10, columnName = "TminDaysSub10") %>% left_join(cherry, ., by=c("year", "location")) 

#First Day Thresholds
#Full Time Series
cherry <- firstDay(tmax<7, columnName = "FirstTmaxSub7") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- firstDay(tmin<0, columnName = "FirstTminFreeze") %>% left_join(cherry, ., by=c("year", "location")) 


### Months
cherry <- firstDay(tmax>4, columnName = "FirstJanTmaxAbove4", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- firstDay(tmax>5, columnName = "FirstFebTmaxAbove5", month=2) %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- firstDay(tmin>(-1), columnName = "FirstJanTminAboveNeg1", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- firstDay(tmin>(-2), columnName = "FirstFebTminAboveNeg2", month=2) %>% left_join(cherry, ., by=c("year", "location")) 


#Max consec Thresholds
cherry <- consecDays(tmin<0, columnName = "MaxConsecTminSub0") %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- consecDays(tmax<0, columnName = "MaxConsecTmaxSub0") %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- consecDays(tmin<0, columnName = "MaxOctConsecTminSub0", month=10) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- consecDays(tmin<0, columnName = "MaxNovConsecTminSub0", month=11) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- consecDays(tmin<0, columnName = "MaxDecConsecTminSub0", month=12) %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- consecDays(tmin>0, columnName = "MaxJanConsecTminAbove0", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- consecDays(tmin>0, columnName = "MaxFebConsecTminAbove0", month=2) %>% left_join(cherry, ., by=c("year", "location")) 

cherry <- consecDays(tmax>10, columnName = "MaxJanConsecTmaxAbove10", month=1) %>% left_join(cherry, ., by=c("year", "location")) 
cherry <- consecDays(tmax>10, columnName = "MaxFebConsecTmaxAbove10", month=2) %>% left_join(cherry, ., by=c("year", "location")) 


cherry <- dplyr::filter(cherry, year>1953)
```
Interpolate Missing Values
```{r}
table(is.na(cherry))
for(i in 8:ncol(cherry)){
  for(j in 1:length(unique(cherry$location)))
  cherry[which(cherry$location==unique(cherry$location)[j]),i] <- zoo::na.approx(cherry[which(cherry$location==unique(cherry$location)[j]),i], rule=2)
}

table(is.na(cherry))
```

We still shouldn't use these years due to our lack of data

```{r}
cherry <- dplyr::filter(cherry, location!="kocation" | year!=2005) #Entire year; will interpolate the winter
cherry <- dplyr::filter(cherry, location!="liestal" | year!=2015) #Missing Entire Year
cherry <- dplyr::filter(cherry, location!="liestal" | year!=2016) #Missing Spring
cherry <- dplyr::filter(cherry, location!="washingtondc" | year!=2002) #Missing Year Entirely
```
  

```{r}
#write.csv(cherry, file = "InitCovariates.csv", row.names = FALSE)

#dat <- read.csv(file="ExCovariates.csv")
```

